#version 450

struct Material {
    vec4 albedo;          
    vec4 diffuse_specular;
    vec4 refractive;  
};

struct Sphere {
    vec4 center_radius;    // xyz:center, w:radius
    Material material;
};

struct Ray {
    vec4 dir;
    vec4 resultColor;
};

struct Triangle {
    vec4 v0;  // xyz: vertex 0
    vec4 v1;  // xyz: vertex 1
    vec4 v2;  // xyz: vertex 2
    Material material;
};

struct Model
{	// 为了满足std140 布局的对齐规则将前三个参数整合到params0中
	ivec4 params0; // x=startIndex, y=count, z=normalinterpolatio (0/1), w=padding
	//int startIndex:起始索引
	//int count:三角形数量
	//bool normalinterpolatio:是否启动表面平滑
	vec4 bboxMin;
	vec4 bboxMax;
	Material material;
};

layout (binding = 0) uniform ParameterUBO {
    Sphere sphere0;
    Sphere sphere1;
    Sphere sphere2;
    Sphere sphere3;
    vec4 light0;
    vec4 light1;
    vec4 light2;
    vec4 camPos;
    vec4 bboxMin;
    vec4 bboxMax;
    vec4 triangleCount;
    vec4 modelCount;
} ubo;

layout(std140, binding = 1) readonly buffer RaySSBOIn {
    Ray rayIn[];
};

 layout(std140, binding = 2) buffer RaySSBOOut {
     Ray rayOut[];
 };

layout (binding = 3, rgba8) uniform image2D outputImage;

layout(binding = 4) uniform sampler2D backgroundImage;

layout(std140, binding = 5) readonly buffer TriangleSSBO {
    Triangle triangles[];
};

layout(std140, binding = 6) readonly buffer ModelSSBO {
    Model models[];
};

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

const int MAX_DEPTH = 20;
const int MAX_STACK_SIZE = MAX_DEPTH * 2 ;
const vec3 BACKGROUND_COLOR = vec3(0.2, 0.7, 0.8);
const float MIN_EPSILON = 0.00001;
const int WIDTH = 1024;
const int HEIGHT = 768;
const float GAMMA = 2.2;
const float PI = 3.14159265358979323846;
const bool draw_sphere = false;

bool ray_aabb_intersect(vec3 orig, vec3 dir, vec3 invDir, vec3 bboxMin, vec3 bboxMax) {
    // TODO-finished
    // implement the bbox intersect for optimization
    vec3 t0 = (bboxMin - orig) * invDir;
    vec3 t1 = (bboxMax - orig) * invDir;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tNear = max(max(tmin.x, tmin.y), tmin.z);
    float tFar  = min(min(tmax.x, tmax.y), tmax.z);

    return tNear <= tFar && tFar > MIN_EPSILON;

    return true;
}

vec3 custom_refract(vec3 I, vec3 N, float eta_out, float eta_in) {
    bool isEntering = dot(I, N) < 0.0;
    vec3 faceNormal = isEntering ? N : -N;
    float cosi = clamp(dot(-I, faceNormal), 0.0, 1.0);
    float eta = isEntering ? eta_in / eta_out : eta_out / eta_in;
    float sint2 = eta * eta * (1.0 - cosi * cosi);
    if (sint2 > 1.0) {
        return vec3(1.0, 0.0, 0.0);
    }
    float k = sqrt(1.0 - sint2);
    vec3 refractDir = eta * I + (eta * cosi - k) * faceNormal;
    return normalize(refractDir);
}

bool ray_triangle_intersect(vec3 orig, vec3 dir, Triangle tri, out float t, out vec3 normal) {
    // TODO
    // implement the triangle intersect

    vec3 v0 = tri.v0.xyz;
    vec3 v1 = tri.v1.xyz;
    vec3 v2 = tri.v2.xyz;
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    // 计算光线方向和第一个边的叉积（P）
    vec3 h = cross(dir, edge2);
    float a = dot(edge1, h);
    // 如果 a 接近 0，光线和平面平行
    if (a > -MIN_EPSILON && a < MIN_EPSILON) {
        return false;
    }
    float f = 1.0 / a;
    // 计算从原点到顶点的向量
    vec3 s = orig - v0;
    // 计算 u 参数
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) {
        return false;
    }
    // 计算第二个叉积（Q）
    vec3 q = cross(s, edge1);
    // 计算 v 参数
    float v = f * dot(dir, q);
    if (v < 0.0 || u + v > 1.0) {
        return false;
    }
    // 计算交点距离 t
    t = f * dot(edge2, q);
    if (t > MIN_EPSILON) {
        // 光线确实击中了三角形
        normal = normalize(cross(edge1, edge2)); // 三角形法线
        return true;
    }

    return false;
}
bool ray_triangle_intersect_my(vec3 orig, vec3 dir, Triangle tri, out float t, out vec3 normal) {
    // Möller–Trumbore 算法
    vec3 v0 = tri.v0.xyz;
    vec3 v1 = tri.v1.xyz;
    vec3 v2 = tri.v2.xyz;
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 S = orig - v0;
    vec3 S1 = cross(dir,edge2);
    vec3 S2 = cross(S,edge1);

    float a = dot(S1, edge1);
    if (a > -MIN_EPSILON && a < MIN_EPSILON){
        return false;
    }
    float coeff = 1.0 / a;
    float t0 = coeff * dot(S2, edge2);
    float b1 = coeff * dot(S1, S);  // 重心坐标u
    float b2 = coeff * dot(S2, dir); // 重心坐标v
    if (t0 >= MIN_EPSILON && b1 >= 0.0 && b2 >= 0.0 && (b1 + b2) >= 1.0){
       t = t0;
       normal = normalize(cross(edge1, edge2)); // 三角形法线
       return true;
    }
    return false;
}

bool ray_sphere_intersect(vec3 orig, vec3 dir, Sphere s, out float t) {
    vec3 L = s.center_radius.xyz - orig;
    float tca = dot(L, dir);
    float d2 = dot(L, L) - tca * tca;
    float r2 = s.center_radius.w * s.center_radius.w;
    if (d2 > r2) return false;
    float thc = sqrt(r2 - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;
    if (t0 > MIN_EPSILON) t = t0;
    else if (t1 > MIN_EPSILON) t = t1;
    else return false;
    return true;
}

struct SceneHit {
    bool hit;
    float distance;
    vec3 point;
    vec3 normal;
    Material material;
};

void scene_intersect(vec3 orig, vec3 dir, out SceneHit nearest) {
    // TODO 
    // You need to modify this function to add a duck model(a lot of triangles)
    int trianglesCount = int(ubo.triangleCount.x); //add 三角形数量

    nearest.hit = false;
    nearest.distance = 1e10;
    // 地板
    if (abs(dir.y) > MIN_EPSILON) {
        float t = -(orig.y + 4.0) / dir.y;
        if (t > MIN_EPSILON && t < nearest.distance) {
            vec3 p = orig + dir * t;
            if (abs(p.x) < 10.0 && p.z < -10.0 && p.z > -30.0) {
                nearest.hit = true;
                nearest.distance = t;
                nearest.point = p;
                nearest.normal = vec3(0.0, 1.0, 0.0);
                vec3 color = (mod(floor(p.x * 0.5 + 1024.0) + floor(p.z * 0.5), 2.0) == 0.0) ? vec3(0.3) : vec3(0.3, 0.2, 0.1);
                nearest.material.albedo = vec4(2.0, 0.0, 0.0, 0.0);
                nearest.material.diffuse_specular = vec4(color, 1.0);
                nearest.material.refractive = vec4(1.0, 0.0, 0.0, 0.0);
            }
        }
    }

    if(draw_sphere){
        Sphere spheres[4] = {ubo.sphere0, ubo.sphere1, ubo.sphere2, ubo.sphere3};
        for (int i = 0; i < 4; i++) {
            float t = 1e10;
            if (ray_sphere_intersect(orig, dir, spheres[i], t) && t < nearest.distance) {
                vec3 p = orig + dir * t;
                nearest.hit = true;
                nearest.distance = t;
                nearest.point = p;
                nearest.normal = normalize(p - spheres[i].center_radius.xyz);
                nearest.material = spheres[i].material;
            }
        }
    }
    vec3 invDir = 1.0 / dir;
    if (ray_aabb_intersect(orig, dir, invDir, ubo.bboxMin.xyz, ubo.bboxMax.xyz)) {
        // 遍历所有三角形
        for (int i = 0; i < trianglesCount; i++) {
            Triangle tri = triangles[i];
            float t;
            vec3 hitPoint, hitNormal;
            if (ray_triangle_intersect(orig, dir, tri, t, hitNormal)) {
                if (t > MIN_EPSILON && t < nearest.distance) {
                    hitPoint = orig + dir * t;
                    nearest.hit = true;
                    nearest.distance = t;
                    nearest.point = hitPoint;
                    nearest.normal = hitNormal;
                    // 设置材质
                    nearest.material = tri.material;
                }
            }
        }
    }
}

bool shadow_intersect(vec3 orig, vec3 dir, float max_dist) {
    // TODO 
    // You need to modify this function to add a duck model(a lot of triangles)

    if(draw_sphere){
        Sphere spheres[4] = {ubo.sphere0, ubo.sphere1, ubo.sphere2, ubo.sphere3};
        for (int i = 0; i < 4; i++) {
            float t = 1e10;
            if (ray_sphere_intersect(orig, dir, spheres[i], t) && t < max_dist) {
                return true;
            }
        }
    }
    vec3 invDir = 1.0 / dir;
    if (ray_aabb_intersect(orig, dir, invDir, ubo.bboxMin.xyz, ubo.bboxMax.xyz)) {
        for (int i = 0; i < int(ubo.triangleCount.x); i++) {
            Triangle tri = triangles[i];
            float t;
            vec3 normal;

            if (ray_triangle_intersect(orig, dir, tri, t, normal)) {
                if (t > MIN_EPSILON && t < max_dist) {
                    return true; // 被三角形挡住
                }
            }
        }
    }

    return false;
}

struct PathSegment {
    vec3 origin;
    vec3 direction;
    vec3 throughput;
    int depth;
};

vec2 direction_to_uv(vec3 dir) {
    float theta = atan(dir.z, dir.x); // [-PI, PI]
    float phi = acos(dir.y);          // [0, PI]
    float u = (theta + PI) / (2.0 * PI); // [0, 1]
    float v = phi / PI;                 // [0, 1]
    return vec2(u, v);
}

vec3 cast_ray(vec3 orig, vec3 dir) {
    // TODO-finished
    // You need to modify this function to add background

    vec3 color = vec3(0.0);
    PathSegment stack[MAX_STACK_SIZE];
    int stackSize = 0;
    stack[stackSize++] = PathSegment(orig, dir, vec3(1.0), 0);

    while (stackSize > 0) {
        PathSegment segment = stack[--stackSize];
        if (segment.depth >= MAX_DEPTH || dot(segment.throughput, segment.throughput) < 0.001) continue;

        SceneHit hit;
        scene_intersect(segment.origin, segment.direction, hit);
        // 未命中时从背景图采样颜色
        if (!hit.hit) {
            vec2 uv = direction_to_uv(segment.direction);
            vec3 bg_color = texture(backgroundImage, uv).rgb;
            color += segment.throughput * bg_color;
            continue;
        }
      
        vec3 p = hit.point;
        vec3 n = hit.normal;
        vec3 v = -segment.direction;
        vec3 diffuse = vec3(0.0);
        vec3 specular = vec3(0.0);
        vec3 lights[3] = {ubo.light0.xyz, ubo.light1.xyz, ubo.light2.xyz};

        for (int i = 0; i < 3; i++) {
            vec3 light_dir = normalize(lights[i] - p);
            float light_dist = length(lights[i] - p);
            vec3 shadow_origin = dot(light_dir, n) < 0.0 ? p - n * MIN_EPSILON : p + n * MIN_EPSILON;
            if (shadow_intersect(shadow_origin, light_dir, light_dist)) continue;

            float diff = max(0.0, dot(n, light_dir));
            diffuse += diff * hit.material.diffuse_specular.rgb;

            vec3 reflect_dir = reflect(-light_dir, n);
            float spec = pow(max(0.0, dot(reflect_dir, v)), hit.material.diffuse_specular.a);
            specular += spec * hit.material.diffuse_specular.rgb;
        }

        color += segment.throughput * (diffuse * hit.material.albedo.x + specular * hit.material.albedo.y);

        if (hit.material.albedo.z > 0.0 && stackSize < MAX_STACK_SIZE) {
            vec3 next_dir = normalize(reflect(segment.direction, n));
            vec3 offset = dot(next_dir, n) < 0.0 ? -n * MIN_EPSILON : n * MIN_EPSILON;
            vec3 next_origin = p + offset;
            vec3 next_throughput = segment.throughput * hit.material.albedo.z;
            stack[stackSize++] = PathSegment(next_origin, next_dir, next_throughput, segment.depth + 1);
        }

        if (hit.material.albedo.w > 0.0 && stackSize < MAX_STACK_SIZE) {
            vec3 refract_dir = custom_refract(segment.direction, n, hit.material.refractive.x, 1.0);
            if (length(refract_dir) > 0.0001) {
                refract_dir = normalize(refract_dir);
                vec3 offset = dot(refract_dir, n) < 0.0 ? -n * MIN_EPSILON : n * MIN_EPSILON;
                vec3 next_origin = p + offset;
                vec3 next_throughput = segment.throughput * hit.material.albedo.w;
                stack[stackSize++] = PathSegment(next_origin, refract_dir, next_throughput, segment.depth + 1);
            }
        }
    }

    return clamp(color, vec3(0.0), vec3(1.0));
}


void main() {
    ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    if (uv.x >= WIDTH || uv.y >= HEIGHT) return;

    uint idx = uv.y * WIDTH + uv.x;

    Ray ray = rayIn[idx];
    vec3 ray_dir = normalize(ray.dir.xyz);
    vec3 ray_orig = vec3(0.0, 0.0, 0.0);
    ray_orig = ubo.camPos.xyz;
    vec3 color = cast_ray(ray_orig, ray_dir);
    
    color = pow(color, vec3(GAMMA));
    
    imageStore(outputImage, uv, vec4(color, 1.0));
    rayOut[idx].resultColor = vec4(color, 1.0);
}